/**
 * Tasks Hook
 *
 * Manages tasks for the user
 */

import { useState, useEffect, useCallback } from "react";
import { getDeviceToken } from "@/lib/auth/device-token";

export type TaskType =
  | "es"
  | "web_test"
  | "self_analysis"
  | "gakuchika"
  | "video"
  | "other";

export type TaskStatus = "open" | "done";

export const TASK_TYPE_LABELS: Record<TaskType, string> = {
  es: "ES作成",
  web_test: "WEBテスト",
  self_analysis: "自己分析",
  gakuchika: "ガクチカ",
  video: "動画・録画",
  other: "その他",
};

export interface Task {
  id: string;
  userId: string | null;
  guestId: string | null;
  companyId: string | null;
  applicationId: string | null;
  deadlineId: string | null;
  title: string;
  description: string | null;
  type: TaskType;
  status: TaskStatus;
  dueDate: string | null;
  isAutoGenerated: boolean;
  sortOrder: number;
  completedAt: string | null;
  createdAt: string;
  updatedAt: string;
  company?: {
    id: string;
    name: string;
  } | null;
  application?: {
    id: string;
    name: string;
  } | null;
  deadline?: {
    id: string;
    title: string;
    dueDate: string;
  } | null;
}

export interface TodayTask {
  mode: "DEADLINE" | "DEEP_DIVE" | null;
  task: Task | null;
  message?: string;
}

export interface CreateTaskInput {
  title: string;
  description?: string;
  type: TaskType;
  companyId?: string;
  applicationId?: string;
  deadlineId?: string;
  dueDate?: string;
}

export interface UpdateTaskInput {
  title?: string;
  description?: string;
  type?: TaskType;
  status?: TaskStatus;
  dueDate?: string | null;
}

function buildHeaders(): Record<string, string> {
  const headers: Record<string, string> = {
    "Content-Type": "application/json",
  };
  if (typeof window !== "undefined") {
    try {
      const deviceToken = getDeviceToken();
      if (deviceToken) {
        headers["x-device-token"] = deviceToken;
      }
    } catch {
      // Ignore errors
    }
  }
  return headers;
}

export interface UseTasksOptions {
  status?: TaskStatus | "all";
  companyId?: string;
  applicationId?: string;
}

export function useTasks(options: UseTasksOptions = {}) {
  const [tasks, setTasks] = useState<Task[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchTasks = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const params = new URLSearchParams();
      if (options.status) params.set("status", options.status);
      if (options.companyId) params.set("companyId", options.companyId);
      if (options.applicationId) params.set("applicationId", options.applicationId);

      const url = `/api/tasks${params.toString() ? `?${params.toString()}` : ""}`;
      const response = await fetch(url, {
        headers: buildHeaders(),
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error("Failed to fetch tasks");
      }

      const data = await response.json();
      setTasks(data.tasks || []);
    } catch (err) {
      setError(err instanceof Error ? err.message : "タスクの取得に失敗しました");
    } finally {
      setIsLoading(false);
    }
  }, [options.status, options.companyId, options.applicationId]);

  useEffect(() => {
    fetchTasks();
  }, [fetchTasks]);

  const createTask = useCallback(
    async (input: CreateTaskInput): Promise<Task | null> => {
      try {
        const response = await fetch("/api/tasks", {
          method: "POST",
          headers: buildHeaders(),
          credentials: "include",
          body: JSON.stringify(input),
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || "Failed to create task");
        }

        const data = await response.json();
        await fetchTasks();
        return data.task;
      } catch (err) {
        setError(err instanceof Error ? err.message : "タスクの作成に失敗しました");
        return null;
      }
    },
    [fetchTasks]
  );

  const updateTask = useCallback(
    async (taskId: string, input: UpdateTaskInput): Promise<boolean> => {
      try {
        const response = await fetch(`/api/tasks/${taskId}`, {
          method: "PUT",
          headers: buildHeaders(),
          credentials: "include",
          body: JSON.stringify(input),
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || "Failed to update task");
        }

        await fetchTasks();
        return true;
      } catch (err) {
        setError(err instanceof Error ? err.message : "タスクの更新に失敗しました");
        return false;
      }
    },
    [fetchTasks]
  );

  const deleteTask = useCallback(
    async (taskId: string): Promise<boolean> => {
      try {
        const response = await fetch(`/api/tasks/${taskId}`, {
          method: "DELETE",
          headers: buildHeaders(),
          credentials: "include",
        });

        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || "Failed to delete task");
        }

        await fetchTasks();
        return true;
      } catch (err) {
        setError(err instanceof Error ? err.message : "タスクの削除に失敗しました");
        return false;
      }
    },
    [fetchTasks]
  );

  const toggleComplete = useCallback(
    async (taskId: string): Promise<boolean> => {
      const task = tasks.find((t) => t.id === taskId);
      if (!task) return false;

      const newStatus = task.status === "open" ? "done" : "open";
      return updateTask(taskId, { status: newStatus });
    },
    [tasks, updateTask]
  );

  return {
    tasks,
    isLoading,
    error,
    refresh: fetchTasks,
    createTask,
    updateTask,
    deleteTask,
    toggleComplete,
  };
}

export function useTodayTask() {
  const [data, setData] = useState<TodayTask>({ mode: null, task: null });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchTodayTask = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch("/api/tasks/today", {
        headers: buildHeaders(),
        credentials: "include",
      });

      if (!response.ok) {
        throw new Error("Failed to fetch today's task");
      }

      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : "今日のタスクの取得に失敗しました");
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchTodayTask();
  }, [fetchTodayTask]);

  const markComplete = useCallback(async (): Promise<boolean> => {
    if (!data.task) return false;

    try {
      const response = await fetch(`/api/tasks/${data.task.id}`, {
        method: "PUT",
        headers: buildHeaders(),
        credentials: "include",
        body: JSON.stringify({ status: "done" }),
      });

      if (!response.ok) {
        throw new Error("Failed to complete task");
      }

      await fetchTodayTask();
      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : "タスクの完了に失敗しました");
      return false;
    }
  }, [data.task, fetchTodayTask]);

  return {
    ...data,
    isLoading,
    error,
    refresh: fetchTodayTask,
    markComplete,
  };
}
